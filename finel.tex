\documentclass[twoside,a4paper,12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{booktabs}

\usepackage[left=3cm,right=3cm,top=2cm,bottom=2cm,asymmetric]{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% hyperlinks in the document
\usepackage{hyperref}
% https://tex.stackexchange.com/questions/823/remove-ugly-borders-around-clickable-cross-references-and-hyperlinks
\hypersetup{
    colorlinks,
    linkcolor={red!80!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% https://tex.stackexchange.com/questions/135649/make-citemy-reference-show-name-and-year
\usepackage{natbib}             % citations including name and year
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% code listings
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.3,0.3,0.3}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.8,0.8,0.8}
\definecolor{BLUE}{rgb}{1.,1.,0.}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{black!10},   
    % commentstyle=\color{black!80},
    commentstyle=\color{codegreen},
    keywordstyle={\bf\ttfamily\color{black}},
    stringstyle={\it\ttfamily\color{black!70}},
    numberstyle=\scriptsize\color{black!70},
    % basicstyle=\footnotesize,
    % breakatwhitespace=false,         
    % breaklines=true,                 
    captionpos=t,                    
    basicstyle=\scriptsize\ttfamily\color{black!90},
    % keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,   
    stepnumber=5,
    firstnumber=1,
    numberfirstline=false,
    belowcaptionskip=-1em,
    % showspaces=false,                
    % showstringspaces=false,
    % showtabs=false,                  
    % tabsize=2
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% escape underscore environment
% https://tex.stackexchange.com/questions/20890/define-an-escape-underscore-environment
\usepackage{url}
\DeclareUrlCommand\code{\urlstyle{tt}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\tabref}[1]{Table~\ref{#1}}

\newcommand{\prog}[1]{\textsf{#1}}

\newcommand{\python}{\prog{Python}}
\newcommand{\numpy}{\prog{NumPy}}
\newcommand{\lapack}{\prog{LAPACK}}

\newcommand{\ie}{{\it i.e.\ }}

\newcommand{\notcolor}{blue}
\newcommand{\note}[1]{{\color{red}\newline(#1)}}
\newcommand{\QM}{{\color{red}(?)}}

\newcommand{\+}[2]{\newcommand#1{{\color{\notcolor}#2}}}
\newcommand{\1}[2]{\newcommand{#1}[1]{{\color{\notcolor}#2}}}
\newcommand{\2}[2]{\newcommand{#1}[2]{{\color{\notcolor}#2}}}

\newcommand{\mat}{\boldsymbol }

\+{\dd}{\mathrm{d}}
\+{\pd}{\partial}
\+{\uuh}{u^h}
\+{\ggh}{g^h}
\+{\vvh}{v^h}
\+{\wwh}{w^h}
\+{\nel}{N}
\+{\young}{E}                   % young's modulus
\+{\area}{A}                    % cross-section area

\+{\shape}{\Phi}                % elementary shape (basis) function
\+{\stm}{\mat K}                % stiffness matrix
\1{\stme}{K_{#1}}       % stiffness matrix entry

\+{\estm}{\mat K^e}               % element stiffness matrix
\1{\estme}{\mat K^e_{#1}}       % element stiffness matrix entry

\+{\vdspl}{\vec d}
\+{\vfrc}{\vec F}

\1{\cO}{\mathcal{O}(#1)}

\begin{document}

\section{Statement of the system}

This program aims to use finite elements methods to solve the boundary
value problem
%
\begin{align}
  \young(x) \area(x) u_{,xx} + f(x) = 0, \label{eq:bvp}
  &&u(L) = g, u_{,x}(0) = -h,
\end{align}
where $L$ is the length, $\young(x)$ is Young's modulus and $\area$ is
the cross section area, $u(x)$ is a deformation of the of the object
in consideration, and shorthand notation for a derivative is written
after a coma in a subscript, e.g. $u_{,x} = \partial u /\partial x$.  The
function $f(x)$ represents the body forces. The $g$ and $h$ are
essential and natural boundary conditions respectively.

Let $u(x)$ be a solution of system \eqref{eq:bvp} then we may write
%
\begin{align}
  0 = \int_0^L (\young(x) \area(x) u_{,xx} + f(x)) w(x) \dd x 
\end{align}
and $w(x)$ is a chosen \emph{weighting (test) function} that satisfies a
criteria $w(L)=0$.
%
Using integration by parts we get
%
\begin{align}
  \int_0^L \young(x) \area(x) u_{,xx} w(x) \dd x 
  -\int_0^L f(x) w(x) \dd x  =
   \int_0^L u_{,x} (\young(x) \area(x) w(x))_{,x} \dd x -\nonumber \\ -
  (u_{,x} (\young(x) \area(x)  w(x))\big|_0^L -
  \int_0^L f(x) w(x) \dd x =  
  %
  \int_0^L u_{,x} (\young(x) \area(x) w(x))_{,x} \dd x -\nonumber \\ -
  (u_{,x}(L) (\young(L) \area(L)  w(L) -
  u_{,x}(0) \young(0) \area(0)  w(0)) 
  -\int_0^L f(x) w(x) \dd x = 0
\end{align}
%
and using the boundary values and the property of the weighting
function, the previous simplifies as
%
\begin{align}
  \int_0^L u_{,x} (\young(x) \area(x) w(x))_{,x} \dd x =  
  \int_0^L f(x) w(x) \dd x + h \young(0) \area(0)  w(0)
  \label{eq:weak-exact}
\end{align}
%
this method is called a \emph{weak (variational)}.

The solution of this system can be found by strong (classical) method
or weak (variational) method. The equivalence with the \emph{strong
  (classical)} method goes under a name \emph{fundamental lemma} which we will not show in here.

To solve the system numerically we will use Galerkin approximation
method. This method uses \eqref{eq:weak-exact} and provides an
approximation of the boundary value problem \eqref{eq:bvp} as
%
\begin{align}
a(\young\area\wwh,\uuh) = (\wwh,f) + h \young(0)\area(0)\wwh(0) \label{eq:weak-approx}
\end{align}
%
where we define the operators $a(y,z) = \int_0^L y_{,x} z_{,x} \dd x$
and $(y,z) = \int_0^L y z \dd x$ for arbitrary functions $y = y(x)$
and $z= z(x)$.

We construct the function
\begin{align}
  \uuh  = \vvh + \ggh \label{eq:galerkin-construc}
\end{align}
%
where $\ggh$ is given by satisfying the essential boundary condition
$\ggh(L) = g$ and $\vvh$ corresponds to the displacement. We
substitute \eqref{eq:galerkin-construc} into \eqref{eq:weak-approx} to
obtain
%
\begin{align}
  a(\young\area\wwh,\vvh) = (\wwh, f) + \young(0)\area(0)\wwh(0)h - 
  a(\young\area\wwh,\ggh)\label{eq:galerkin}
\end{align}
%
the weighting function can be defined as
%
\begin{align}
  \wwh = \sum_{i=0}^{\nel-1} c_i \shape_i \label{eq:wwh-sum}
\end{align}
%
where $\shape_i$ is so-called a \emph{basis (shape) function} for
element $i$. Similarly, we define
%
\begin{align}
  \vvh = \sum_{i=0}^{\nel-1} d_i \shape_i \label{eq:vvh-sum}
\end{align}
where $c_i, d_i$ are constants.

After substitution of \eqref{eq:wwh-sum} and \eqref{eq:vvh-sum} into
the \eqref{eq:galerkin} and using the bilinearity property of
operators $a(\cdot,\cdot)$ and $(\cdot,\cdot)$ we get an expression
%
\begin{align}
  \sum_{j=0}^{\nel-1} a(\young\area\shape_i, \shape_j) d_j = (\shape_i, f) + \young(0)\area(0)\shape_i(0) h - a(\young\area\shape_i,\shape_\nel)g. \label{eq:galerkin-row}
\end{align}
%
Using a notation
%
\begin{subequations}
  \begin{align}
    \stme{ij} =& a(\young\area\shape_i,\shape_j) = \int_0^L \young(x)\area(x)\shape_{i,x}(x),\shape_{j,x}(x) \dd x \label{eq:stme} \\ 
    F_i =& (\shape_i,f) + \young(0)\area(0)\shape_i(0) h - a(\young\area\shape_i,\shape_{\nel}) g .
  \end{align}\label{eq:fem-stme-fi}
\end{subequations}
%
Then equation \eqref{eq:galerkin-row} can be rewritten as
%
\begin{align}
  \sum_{j=0}^{\nel-1} \stme{ij} d_j = F_i
\end{align}
or more concisely as
\begin{align}
\stm \vdspl = \vfrc \label{eq:concise-eq}
\end{align}
where $\stm$ is a \emph{stiffness matrix}, $\vdspl$ is a
\emph{displacement vector} and $\vfrc$ is a \emph{force vector}.

\section{First problem}

Consider boundary value problem \eqref{eq:bvp} where $g=h =0$ with a
constant force as $f(x) = q$, where $q=-1$, length of the piece is
$L=1$, cross-section area and young modulus are $A(x) = E(x) = 1$.

\subsection{Shape function}

We define the basis function and find its derivative for each element
$i$ of $\nel$ elements. In the middle elements we get
\begin{align}
\shape_i(x) =& \frac{x-x_{i-1}}{h_{i-1}}, &\shape_{i,x}(x) =& \frac{1}{h_{i-1}},&&\text{for } x_{i-1} \leq x \leq x_i \\
\shape_i(x) =& \frac{x_{i+1}-x}{h_{i}},  &\shape_{i,x}(x) =& -\frac{1}{h_{i}}, &&\text{for }x_i \leq x \leq x_{i+1} \\
\shape_i(0) =& 0,                       &\shape_{i,x}(0) =& 0,                &&\text{elsewhere.}
\end{align}
%
whereas for the boundary node we have
%
\begin{align}
\shape_0(x) =& \frac{x_1-x}{h_{0}},             &\shape_0(x) =& -\frac{1}{h_{0}},                          &&\text{for } x_0 \leq x \leq x_{1} \\
\shape_\nel(x) =& \frac{x-x_{\nel-1}}{h_{\nel-1}},&\shape_\nel(x) =& \frac{1}{h_{\nel-1}},             &&\text{for } x_{\nel-1} \leq x \leq x_\nel .
\end{align}

\subsection{\python\ Implementation}

Then we compute the values for the stiffness matrix using numerical
integration. In \python\ this can be done using \code{scipy.integrate}
function with a \code{integrate.quad} for a quadrature rule. The
output array contains a tupple containing the value of integral and
the maximum error of the result.

At first, we have integrated from the limits of $0$ all the way
thorough the length of the element $L$. This caused a problem when the
number of elements were greater than $16$. This was due to the fact
that the shape function is defined piecewise, and the results of
numerical integration were not sufficiently accurate. The way to
address this issue was to integrate only in the immediate surroundings
of each point, where the shape functions are actually
non-zero. However, this raised another issue, because the shape
functions were defined even out of the interval $[0,1]$. To avoid
integration in this area, we have hard-coded constrains directly to
the shape function. This could be obviously corrected, but because
the stiffness matrix will be computed element-wise in future version
of this code, it was neglected at this stage.

After constructing element stiffness matrix and the force vector, we
have proceed to the solution of the system \eqref{eq:concise-eq}. In
the first attempt, we have found the displacement vector by inverting
the stiffness matrix using \code{np.linalg.inv} function (we imported
\numpy\ library as \code{np}). So in the current version, we
solve the system using \code{np.linalg.solve} function, which uses
\lapack\ routine \code{_gesv}. A performance benchmark has shown
that for a $5000$ elements the solution of the system using the
\code{np.linalg.solve} is about four times than using matrix inversion
(\ie $2.5$ seconds compared to $8.6$ seconds on Intel Core i5-3470 CPU
at a clock frequency of 3.20GHz).
%
\note{it would be interesting to see what order of $N$ is the
  computational cost. It should be $\cO{N^2}$ for gaussian elimination
  and $\cO{N^3}$ for matrix inversion. }

The code for the computation is shown as follows.

\lstinputlisting[language=python, style=mystyle, breaklines=true]{galerkin.py}


\subsection{Results}

The results are depicted in \figref{fig:displacement}. The simulation
was done for eight free elements. The material is fixed at the point
$x=1$ at a position $0$. The solution is exact at the nods.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{displacement.eps}
  \caption{Dependence of the displacement on the position (x-axis) for
    a computation of eight degrees of freedom. Numerical results at
    the nodes (red dots) are linearly interpolated (red lines) and
    compared to the exact solution (blue line).}
  \label{fig:displacement}
\end{figure}

The output of the program follows.
%
The first part corresponds to the computational cost (in seconds)
spend in the construction of force vector, stiffness matrix and on the
solution of the system. The values are very small for this

Further, the stiffness matrix and the force vector are printed and
finally the solution for the displacement is shown both as a numerical
result and exact solution obtained analytically. As the numerical
results are exact in this case, also the norm of the difference
between the numerical and analytical results is zero.
%
\note{the result at the nodes is 0, but what about the result on the
  midpoints? Hughes seems to talk about relative error in $u_{,x}$
  what is that useful for?  How is the order of convergence?}

\tabref{tab:comp-cost} shows the computational results for the
simulation using $5000$ elements. The remaining parameters are
identical to the code presented. As seen in this example, the
construction of the stiffness matrix is the most time consuming task
despite the fact, that we do not compute the zero elements of the
matrix. The relatively high cost is caused due to numerical
integration.

In the following section we will focus on the computation of the
stiffness matrix element-wise.

\begin{table}
  \centering
  \label{tab:comp-cost}
\caption{Computational cost of the solving of the system for $N=5000$.}
\begin{tabular}{ll}
  \toprule
  Task & cost (seconds)\\
  \midrule
  Constructing stiffness matrix: & 7.161638498306274   \\
  Constructing force vector:     & 0.33005428314208984 \\
  Solving the system:            & 2.460254430770874   \\
  \bottomrule
\end{tabular}
\end{table}

\lstinputlisting[breaklines=true]{galerkin.out}

\section{Element-wise Construction of Stiffness Matrix and Force Vector}

The time of construction of the stiffness matrix for this case has
reduced from $7.16$ seconds to $0.05$ seconds in a computation of
$N= 5000$ nodes (as shown in the \tabref{tab:comp-cost}). This is
probably because now the stiffness is given explicitely, rather then
integrated from the shape functions.

\figref{fig:element} shows the results of the elementwise construction
of the stiffness matrix. This now also allows setting elements of
different length.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{element.eps}
  \caption{Element wise construction of the stiffness matrix.}
  \label{fig:element}
\end{figure}

\lstinputlisting[language=python, style=mystyle, breaklines=true]{element.py}

-\note{it remains to explain the element-wise construction of the stiffness matrix}

\section{Combining Solid and Flow Mehcanics}

This section aims to develop a model combining the mechanics for solid and flow. This aims to simulate the formation of the composite strucutre of carbon fibre and resin. 

Recall the boundary value problem \eqref{eq:bvp}  which now reads as
%
\begin{align}
  u_{,xx} + f(x,t) = 0, \label{eq:bvp-t}
  &&u(L) = g, u_{,x}(0) = -h,
\end{align}
%
Let's consider the body forces $f(x,t)$ involved in the material
during the proces of curration. Then the resin is in its liquid state
and the carbon fibre (solid) acts as a porous material through which
the resin can flow. So the body forces read as\note{check the signs}
%
\begin{align}
  f(x,t) = F_g + F_r + F_m      , \label{eq:const}
\end{align}
%
where the gravitational force corresponds to
%
\begin{align}
F_g = m(x,t) g, \label{eq:grav-force}
\end{align}
%
where $g$ is gravitational acceleration constant, $m(x,t)$ represents
the total mass combining the contribution from the solid $m_s$ and
resin $m_r(x,t)$ as $m(x,t) = m_s(x) + m_r(x,t)$. The total mass at a
point $x$ will change in time, as the resin will accumulate as a head
in the top of the material. However, for a small deformations we
assume $m_s(t) = const$, $m_r(t)=const$.

The forces in the material are 
\begin{align}
  F_m = - (\sigma -  P(x,t))_{,x}, \label{eq:force-material}
\end{align}
%
where $\sigma$ is the stress in the solid part and $P(x,t)$ is the
pressure of the resin which acts in the opposite direction of the
stress. The pressure combines the hydrostatical pressure of the resin,
$P_h$, and applied pressure, $P_a(t)$, $P(x,t) = P_h(x) + P_a(t)
$. Because $P_h \ll P_a$, we assume $P(x,t) = P_a(t)$.

The inertia of the resin, can be characterised by a
%
\begin{align}
    F_r = m_r(x) v_{r,t}(x,t), \label{eq:force-resin}
\end{align}
%
where and $v_r$ is the velocity of the flow of the resin through the
pores of the carbon fibre, which is found according to the Darcy's law
that reads as
%
\begin{align}
  v_r(x,t) = \frac{K}{\mu} P_{a,x}, \label{eq:darcy}
\end{align}
%
\note{is $P_a$ space-dependent? If not pehaps it is not a good idea to
  ignore the hydrostatic pressure? This is because then this term
  would vanish and it is the only time-dependent term. Hence, the
  equations would reduce to static equilibrum equations.}
%
so its time derivative gives us
\begin{align}
  v_{r,t}(x,t) = \frac{K}{\mu} P_{a,xt}, \label{eq:darcy-ddt}
\end{align}
assuming that the $K$ and $\mu$ remain constant.
%
Putting \eqref{eq:darcy-ddt} and \eqref{eq:force-resin} together we obtain
%
\begin{align}
  F_r = m_r(x) \frac{K}{\mu} P_{a,xt} \label{eq:force-resin-final}.
\end{align}

We can now put \eqref{eq:grav-force}, \eqref{eq:force-material}, and
\eqref{eq:force-resin-final}, back to \eqref{eq:const}  to get
%
\begin{align}
  f(x,t) = - m g - (\sigma -  P_a(t))_{,x}  +m_r(x) \frac{K}{\mu} P_{a,xt}
\end{align}
%
then we can plug the boundary value problem \eqref{eq:bvp-t} into
\eqref{eq:concise-eq}, in which we use \eqref{eq:fem-stme-fi}.



\end{document}
